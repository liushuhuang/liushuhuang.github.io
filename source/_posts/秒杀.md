---
title: 秒杀
date: 2023-2-21
description: 秒杀系统的简单思路
tags: JAVA 秒杀
top_img: transparent
cover:    

---

## 秒杀场景分析

秒杀的主要场景有两种：

一种是抢红包类型的，抢到多少就是多少，不会有多余的逻辑需要考虑，重心在于如何实现限流，以及如何防止超卖，少买现象。

第二种是需要涉及到付款的，这个时候就需要考虑库存回收了，超过多久没有付款，就需要讲库存进行回收，用于他人继续进行秒杀。

## 抢红包类型

抢红包类型的话，比较简单，问题主要是两个，解决超卖少卖，解决大流量问题

### 超卖问题

如果不加任何控制，大量请求进来，无法做到立马更新数据库对库存进行扣减并实时通知其他线程，，就得导致只卖100个，但是同时1000人进行抢购，同时对数据库进行操作，一下子卖出去1000份。就会造成超卖。

对应抢红包类型，不会出现少卖的问题，因为一旦抢到了，就没有后续操作。



#### 1.加锁

要解决超卖问题最好的就是加锁，对数据库加锁，每次去数据库查询库存，和减少库存的时候，都需要先获取锁，获取到了锁就进行操作，没有获取到就进行等待，这样就可以避免同时多个线程操作数据库导致的超卖问题了。



##### 1.1悲观锁

查询的时候就加锁，select .....  for update，拿到读锁的同时，提前获取写锁



同时锁分为表锁和行锁，行锁可能出现死锁，而表锁的效率慢

##### 1.2乐观锁

乐观锁并不是真实存在的锁，而是在更新的时候判断此时的库存是否是之前查询出的库存，如果相同，表示没人修改，可以更新库存，否则表示别人抢过资源，不再执行库存更新。类似如下操作：

```sql
update tb_sku set stock=2 where id=1 and stock=7;

SKU.objects.filter(id=1, stock=7).update(stock=2)
```

##### 总结

对于两种锁，都能都实现防止超卖的功能，但是加锁的话，要注意的是数据库的隔离级别，不同的隔离级别会造成不同的影响，并发事务在不同的隔离级别下会出现不同的问题。这个需要深入研究。

#### 2. 分阶段排队下单方案

将提交操作变成两段式：

- 第一阶段申请，申请预减减库，申请成功之后，进入消息队列；
- 第二阶段确认，从消息队列消费申请令牌，然后完成下单操作。 查库存 -> 创建订单 -> 扣减库存。通过分布式锁保障解决多个provider实例并发下单产生的超卖问题。

**申请阶段：**

- 将存库从MySQL前移到Redis中，所有的预减库存的操作放到内存中，由于Redis中不存在锁故不会出现互相等待，并且由于Redis的写性能和读性能都远高于MySQL，这就解决了高并发下的性能问题。



**确认阶段：**

通过队列等异步手段，将变化的数据异步写入到DB中。



引入队列，然后数据通过队列排序，按照次序更新到DB中，完全串行处理。当达到库存阀值的时候就不在消费队列，并关闭购买功能。这就解决了超卖问题。

<img src="https://img-blog.csdnimg.cn/20210603091538546.png" referrerPolicy="no-referrer"/>

这种方案还可以提升，因为在最终的落库阶段，还是需要在数据库进行，还是需要进行加锁，释放锁的过程，也就是说最终落库的时候花费的时间大大超过预减库存阶段的时间。



为了提升性能，可以对分布式锁进行优化，也就是分段进行加锁，将数据库的库存进行分段存储，比如我要卖1000件，分成10段，每一段100件，这样就可以支持每一次都没有同时有10个数据库请求进操作。

当然这样会有一点的缺点：

- 首先，你得对一个数据分段存储，一个库存字段本来好好的，现在要分为20个分段库存字段；
- 其次，你在每次处理库存的时候，还得自己写随机算法，随机挑选一个分段来处理；
- 最后，如果某个分段中的数据不足了，你还得自动切换到下一个分段数据去处理。

所以其实这种方案还是有一定的优化空间。

### 抢购类型

这个类型其实和抢红包相比会多一个下单付款的过程。其实分析起来是一样的，但是会有一个少买问题



如果用户抢到了下单资格，但是没有付款，这个时候其实库存已经预减了，这种后续用户来抢购，就会少一个库存，这就造成了少卖问题。



这个少卖在分阶段下单方案非常明显，因为是先预减库存，再同步数据库，这中间其实有一定的时间差，会导致redis中的数据和数据库的数据不一样。





## PS

本篇文章是学习阶段做的笔记，并没有实践完成，所以很多地方并没有考虑到或者解释的不对，后续会进行更新

## 参考

https://blog.csdn.net/crazymakercircle/article/details/120521674

https://blog.csdn.net/belongtocode/article/details/103395802